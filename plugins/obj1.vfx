0 value me
create os  $100 allot
variable >os 

: [[  me >os @ os + !  >os @ cell+ $ff and >os !  to me ;
: ]]  >os @ cell- $ff and >os !  >os @ os + @ to me ;
: var  create dup , cell+  does> @ me + ;
: as  to me ;

: create-kind  ( n - <name> )
    create , 0 , 0 , ;

0
    var lnk
    var kind
    var en
    var flags
    var child
    var x
    var y
    var w
    var h
    var vx
    var vy
    var 'step
    var 'draw
    var 'motion
\    var 'react
create-kind %object

: sizeof  @ ;
: kind.init  cell+ ;   \ maybe only for compile-time stuff ...
: kind.serialize  cell+ cell+ ;
: extend  sizeof ;

: ?execute  ?dup if execute then ;

: link-after  ?dup 0= if exit then  me swap [[ lnk ! ]] ;
    
: object  ( n - me=obj )
    me   here as  swap allot&erase  link-after ;

%object extend  create %pool , 0 ,

: independent  0 as ;

: /child  \ dummy object, sole purpose is to be an anchor
    me 
    independent %object sizeof object  
    me swap [[ child ! ]] ;

: init  ( - )
    kind @ kind.init @ ?execute ;

: static  ( kind - me=obj )
    dup sizeof object kind !  en on  init ;

: pool ( n size - me=pool )
    dup 2 < if -1 abort" Cannot define a pool of less than 2." then
    %pool static  me [[
    /child
    swap 0 ?do  dup object  loop  
    drop
    ]] ;

: @child  child @ ?dup 0= if me [[ /child me ]] then ;
: children  @child [[ ;
: end-children  ]] ;  
: >next  [[ lnk @ ]] ;
: >first  [[ child @ ]] dup if >next then ;

: one  ( kind pool - obj )
    >first [[
    begin  me  while 
        en @ 0= if  kind !  en on  me ]] exit then
        lnk @ to me
    repeat
    -1 abort" Out of objects in pool" ;

0 value xt
: each  ( xt pool - )  ( ... - continue? ... )
    >first ?dup 0= if drop exit then
    [[  xt >r  to xt    
        begin  me  while
            xt execute 0= if  leave  then
            lnk @ to me
        repeat
    ]]  r> to xt ;

: each>  r> swap each ;

: vacate  ( pool - )  each> en off -1 ;  DoNotsin

: draw>  r> 'draw ! ;     DoNotSin
: step>  r> 'step ! ;     DoNotSin
: motion>  r> 'motion ! ; DoNotSin

: draw    x v@ at  'draw @ ?execute   me each>  en @ if  recurse  then  -1 ;  DoNotSin
: step    'step @ ?execute   me each>  en @ if  recurse  then  -1 ;  DoNotSin
: motion  'motion @ ?execute me each>  en @ if  recurse  then  -1 ;  DoNotSin
