0 value me
create os  $100 allot
variable >os 

: [[  me >os @ os + !  >os @ cell+ $ff and >os !  to me ;
: ]]  >os @ cell- $ff and >os !  >os @ os + @ to me ;
: objvar  create dup , cell+  does> @ me + ;
: as  to me ;

0
    objvar lnk
    objvar kind
    objvar en
    objvar flags
    objvar child
    objvar x
    objvar y
    objvar w
    objvar h
    objvar vx
    objvar vy
    objvar 'step
    objvar 'draw
    objvar 'react
    objvar 'motion
create %object , 0 ,  \ second cell is init; maybe only for compile time stuff?

: sizeof  @ ;
: kind.init  cell+ ;
: extend  sizeof ;

: ?execute  ?dup if execute then ;

: link-after  ?dup 0= if exit then  me swap [[ lnk ! ]] ;
    
: object  ( n - me=obj )
    me   here as  swap allot&erase  link-after ;

%object extend  create %pool ,

: independent  0 as ;

: /child
    me locals| p |
    independent %object sizeof object  \ dummy object, sole purpose is to be an anchor
    me p [[ child ! ]] ;

: pool ( n size - me=pool )
    %pool sizeof object  me locals| p |
    /child
    swap 0 ?do  dup object  loop  
    drop
    p as ;

\ this doesn't seem great
: ?child  child @ ?dup 0= if me [[ /child me ]] then ;
: children  ?child [[ ;
: end-children  ]] ;  

: >next  [[ lnk @ ]] ;
: >first  [[ child @ ]] >next ;

: one  ( kind pool - obj )
    me [[ >first as
    begin  me  while 
        en @ 0= if  kind !  en on  me ]] exit then
        lnk @ to me
    repeat
    -1 abort" Out of objects in pool" ;

0 value xt
: each  ( pool xt - )  ( - continue? )
    xt >r  to xt  >first [[  
        begin  me  while
            xt execute 0= if  leave  then
            lnk @ to me
        repeat
    ]]  r> to xt ;

: each>  r> each ;

: vacate  ( pool - )
    each> en off -1 ;

: draw>  r> 'draw ! ;
: step>  r> 'step ! ;
: react>  r> 'react ! ;
: motion>  r> 'motion ! ;

: init  ( - )
    kind @ kind.init @ ?execute ;

: static  ( kind - me=obj )
    dup sizeof object kind ! init ;


