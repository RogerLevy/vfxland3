0 value me
create os  $100 allot
variable >os 

: [[  me >os @ os + !  >os @ cell+ $ff and >os !  to me ;
: ]]  >os @ cell- $ff and >os !  >os @ os + @ to me ;
: objvar  create dup , cell+  does> @ me + ;
: as  to me ;


0
    objvar lnk
    objvar kind
    objvar en
    objvar flags
    objvar x
    objvar y
    objvar w
    objvar h
    objvar vx
    objvar vy
    objvar 'step
    objvar 'draw
    objvar 'react
    objvar 'motion
create %object , 0 ,

: sizeof  @ ;
: kind.init  cell+ ;

: ?execute  ?dup if execute then ;

: link-after  ?dup 0= if exit then  me swap [[ lnk ! ]] ;
    
: object  ( n - me=obj )
    me >r  here as  allot&erase  r> link-after ;

create %pool %object sizeof ,

: pool ( n size - me=pool )
    0 as  %pool object  me [[
    here -rot  swap 0 ?do  dup object to me  loop  
    drop  ]] ;

: one  ( kind - me=obj )
    lnk @ as  begin
        en @ 0= if  en on  kind !  exit then
    lnk @ dup to me 0= until
    nip  -1 abort" Out of dynamic objects" ;

: >first  [[ lnk @ ]] ;

0 value xt
: each  ( pool xt - )  ( - continue? )
    xt >r  to xt  >first [[  
        begin  me  while
            xt execute 0= if  leave  then
            lnk @ to me
        repeat
    ]]  r> to xt ;

: each>  r> each ;

: vacate  ( pool - )
    each> en off -1 ;

: draw>  r> 'draw ! ;
: step>  r> 'step ! ;
: react>  r> 'react ! ;
: motion>  r> 'motion ! ;

: extend  sizeof ;

: init  ( - )
    kind @ kind.init @ ?execute ;

: static  ( kind - me=obj )
    dup sizeof object kind ! init ;