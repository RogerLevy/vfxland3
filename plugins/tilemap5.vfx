16 constant tilesize
2048 constant banksize
banksize tilesize / bankcols
banksize dup al_create_bitmap constant tbank
banksize tilesize / dup * stack tstack
variable stride  20 stride !

:noname
    0 0 at  banksize tilesize / 0 do  
        at@  banksize tilesize / 0 do
            tbank tilesize dup subbmp tstack push
        loop
        tilesize + at
    loop ; execute

: @tile  ( n - flags bmp ) dup 28 rshift swap $0fffffff and tstack get ;
: tile+  ( n - ) @tile mblit tilesize 0 +at ;
: tiles  ( a n - ) 0 ?do @+ tile+ loop drop ;

: scrolled  ( x y - ofs )
    over tilesize mod negate  over tilesize mod negate  +at 
    tilesize / stride @ *  swap tilesize / + ;

: !tile  ( bmp n - )

: !tile  ( n bmp n2 - subbmp )
    locals| n2 bmp n |
    n bmp bmpw tilesize / /mod swap tilesize * swap tilesize * at
    bmp tilesize dup subbmp
    n2 bankcols /mod swap tilesize * swap tilesize * at
    ( sub-bitmap ) dup tbank bcopy -bmp ;

\ -----------------------------------------------------------------------------
\ collisions

require plugins/delta.vfx

\ what sides the object collided
0 value lwall?
0 value rwall?
0 value floor?
0 value ceiling?

1 constant BIT_CEL
2 constant BIT_FLR
4 constant BIT_WLT
8 constant BIT_WRT

\ -----------------------------------------------------------------------------

module collisioning    

    defer on-tilemap-collision ( tileval - )
    ' drop is on-tilemap-collision

    defer tile@props  ( tileval - bitmask )
    : default-tile@props  0 >= ;
    ' default-tile@props is tile@props

    0 value map
    tilesize s>f fvalue gap
    0e fvalue nx
    0e fvalue ny
    0 value t

    : cel? BIT_CEL and ; \ ' ceiling '
    : flr? BIT_FLR and ; \ ' floor '
    : wlt? BIT_WLT and ; \ ' wall left '
    : wrt? BIT_WRT and ; \ ' wall right '
        
    : px  x fs@ ;
    : py  y fs@ ;
    : mbw w fs@ ;
    : mbh h fs@ ;

    : xy>cr  ( f: x y - c r )  gap f/ f>s gap f/ f>s swap ;
    : pt  ( f: x y - n )  xy>cr  stride * + map get  dup to t  tile@props ;          

    ( increment coordinates )
    : ve+  fswap  gap f+  px mbw f+ 1e f-  fmin  fswap ;
    : he+  gap f+  mbh ny f+ 1e f-  fmin ;

    : +vy  +to ny  ny py f- delta f/ vy fs! ;
    : +vx  +to nx  nx px f- delta f/ vx fs! ;

    ( push up/down )
    : pu ( f:xy ) fnip gap fmod fnegate +vy
        true to floor?  t on-tilemap-collision  ;
    : pd ( f:xy ) fnip gap fmod fnegate gap f+ +vy
        true to ceiling?  t on-tilemap-collision ;

    ( check up/down )
    : cu  mbw gap f/ f>s 2 + 0 do  f2dup pt cel? if pd unloop exit then ve+  loop f2drop ;
    : cd  mbw gap f/ f>s 2 + 0 do  f2dup pt flr? if pu unloop exit then ve+  loop f2drop ;

    ( push left/right )
    : pl ( f:xy ) fdrop gap fmod fnegate +vx
        true to rwall?  t on-tilemap-collision ;
    : pr ( f:xy ) fdrop gap fmod fnegate gap f+ +vx
        true to lwall?  t on-tilemap-collision ;

    ( check left/right )
    : cl  mbh gap f/ f>s 2 + 0 do  f2dup pt wrt? if pr unloop exit then he+  loop f2drop ;
    : crt mbh gap f/ f>s 2 + 0 do  f2dup pt wlt? if pl unloop exit then he+  loop f2drop ;

    : ud  vy fs@ f0<> if  vy fs@ f0< if  px ny cu  else  px ny mbh f+ cd  then then ;
    : lr  vx fs@ f0<> if  vx fs@ f0< if  nx ny cl  else  nx mbw f+ ny crt  then then ;

    : init  ( - )
        px vx fs@ delta f* f+ to nx  py vy fs@ delta f* f+ to ny 
        0 to lwall?  0 to rwall?  0 to floor?  0 to ceiling? ;

    : collide-tilemap  ( a stride - )
        stride !  to map  init ud lr ;

    export collide-tilemap
    export on-tilemap-collision
    export tile@props
    
end-module
